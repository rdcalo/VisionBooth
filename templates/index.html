<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PhotoBooth Web - Photo Strip</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        h1 {
            color: white;
            margin-bottom: 30px;
            font-size: 3em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 50px rgba(0,0,0,0.3);
            max-width: 1000px;
            width: 100%;
        }

        #videoContainer {
            position: relative;
            width: 100%;
            background: #000;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        #video, #processedFrame {
            width: 100%;
            height: auto;
            display: block;
        }

        #processedFrame {
            display: none;
        }

        .status {
            background: #f0f0f0;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .status-text {
            font-size: 1.5em;
            color: #333;
            margin-bottom: 10px;
        }

        .gesture-info {
            font-size: 1.2em;
            color: #666;
        }

        .capture-progress {
            font-size: 1.8em;
            color: #667eea;
            font-weight: bold;
            margin: 10px 0;
        }

        .countdown {
            font-size: 5em;
            color: #ff4444;
            font-weight: bold;
            text-align: center;
            margin: 20px 0;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #ddd;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.2s;
        }

        #canvas {
            display: none;
        }

        .strip-preview {
            display: none;
            margin-top: 20px;
            text-align: center;
        }

        .strip-preview.show {
            display: block;
        }

        .strip-preview img {
            max-width: 400px;
            width: 100%;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            margin: 20px 0;
        }

        .download-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.2em;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: transform 0.2s;
            margin: 10px;
        }

        .download-btn:hover {
            transform: scale(1.05);
        }

        .download-btn:active {
            transform: scale(0.98);
        }

        .performance-info {
            font-size: 0.9em;
            color: #999;
            margin-top: 10px;
        }

        .fps-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .fps-good { background-color: #4CAF50; }
        .fps-ok { background-color: #FFC107; }
        .fps-bad { background-color: #F44336; }

        .quality-badge {
            display: inline-block;
            background: #4CAF50;
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.8em;
            margin-left: 10px;
        }

        .strip-badge {
            display: inline-block;
            background: #FF6B6B;
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.8em;
            margin-left: 10px;
        }
    </style>
</head>
<body>
    <h1>üì∏ PhotoBooth Web <span class="quality-badge">HD Quality</span> <span class="strip-badge">4-Photo Strip</span></h1>
    
    <div class="container">
        <div id="videoContainer">
            <video id="video" autoplay playsinline></video>
            <img id="processedFrame" alt="Processed frame">
        </div>

        <div class="status">
            <div class="status-text" id="statusText">Starting...</div>
            <div class="gesture-info" id="gestureInfo">No gesture detected</div>
            <div class="capture-progress" id="captureProgress"></div>
            <div id="progressContainer" style="display: none;">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>
            <div class="countdown" id="countdown" style="display: none;"></div>
            <div class="performance-info" id="performanceInfo">FPS: --</div>
        </div>

        <div class="strip-preview" id="stripPreview">
            <h2>üéâ Your Photo Strip is Ready!</h2>
            <img id="stripImage" src="" alt="Photo strip">
            <div>
                <button class="download-btn" onclick="downloadStrip()">üì• Download Strip</button>
                <button class="download-btn" onclick="startNewStrip()">üîÑ Take New Strip</button>
            </div>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const socket = io();
        const video = document.getElementById('video');
        const processedFrame = document.getElementById('processedFrame');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const statusText = document.getElementById('statusText');
        const gestureInfo = document.getElementById('gestureInfo');
        const countdown = document.getElementById('countdown');
        const progressContainer = document.getElementById('progressContainer');
        const progressFill = document.getElementById('progressFill');
        const captureProgress = document.getElementById('captureProgress');
        const performanceInfo = document.getElementById('performanceInfo');
        const stripPreview = document.getElementById('stripPreview');
        const stripImage = document.getElementById('stripImage');

        let canSend = true;
        let frameCount = 0;
        let lastFpsUpdate = Date.now();
        let currentState = 'PROMPT_TIMER';
        let processingTimeout = null;
        let lastFrameTime = 0;
        let currentStripFilename = null;
        let lastCaptureTriggered = false;  // NEW: Track if we already triggered capture

        // Performance settings
        const SCALE_FACTOR = 0.35;
        const JPEG_QUALITY = 0.5;
        const FRAME_INTERVAL = 200;
        const RESPONSE_TIMEOUT = 2000;

        // Access webcam
        navigator.mediaDevices.getUserMedia({ 
            video: { 
                width: { ideal: 1920 },
                height: { ideal: 1080 },
                facingMode: 'user'
            } 
        })
        .then(stream => {
            video.srcObject = stream;
            video.onloadedmetadata = () => {
                canvas.width = video.videoWidth * SCALE_FACTOR;
                canvas.height = video.videoHeight * SCALE_FACTOR;
                
                console.log(`üìπ Video Resolution: ${video.videoWidth}x${video.videoHeight}`);
                console.log(`üîç Detection Resolution: ${canvas.width}x${canvas.height}`);
                
                startSending();
            };
        })
        .catch(err => {
            console.error('Error accessing camera:', err);
            statusText.textContent = 'Error: Cannot access camera';
        });

        function startSending() {
            setInterval(() => {
                const now = Date.now();
                
                if (now - lastFrameTime < FRAME_INTERVAL) {
                    return;
                }
                
                if (canSend) {
                    canSend = false;
                    lastFrameTime = now;
                    
                    if (processingTimeout) {
                        clearTimeout(processingTimeout);
                    }
                    
                    processingTimeout = setTimeout(() => {
                        console.warn('‚ö†Ô∏è Backend timeout, forcing reset');
                        canSend = true;
                    }, RESPONSE_TIMEOUT);
                    
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    const imageData = canvas.toDataURL('image/jpeg', JPEG_QUALITY);
                    
                    socket.emit('video_frame', { image: imageData });
                    updateFPS();
                }
            }, 50);
        }

        function updateFPS() {
            frameCount++;
            const now = Date.now();
            const elapsed = now - lastFpsUpdate;
            
            if (elapsed >= 1000) {
                const fps = Math.round((frameCount / elapsed) * 1000);
                
                let indicator = '';
                if (fps >= 4) {
                    indicator = '<span class="fps-indicator fps-good"></span>';
                } else if (fps >= 2) {
                    indicator = '<span class="fps-indicator fps-ok"></span>';
                } else {
                    indicator = '<span class="fps-indicator fps-bad"></span>';
                }
                
                performanceInfo.innerHTML = `${indicator}FPS: ${fps} | Detection: ${canvas.width}x${canvas.height} | Capture: ${video.videoWidth}x${video.videoHeight}`;
                frameCount = 0;
                lastFpsUpdate = now;
            }
        }

        socket.on('state_update', (data) => {
            if (processingTimeout) {
                clearTimeout(processingTimeout);
                processingTimeout = null;
            }
            
            canSend = true;
            
            // Detect state changes
            const stateChanged = (currentState !== data.state);
            currentState = data.state;
            
            // Reset capture trigger flag when state changes away from CAPTURE_DONE
            if (stateChanged && currentState !== 'CAPTURE_DONE') {
                lastCaptureTriggered = false;
            }
            
            // Update capture progress display
            if (data.capture_count !== undefined && data.total_captures !== undefined) {
                if (data.capture_count > 0) {
                    captureProgress.textContent = `üì∏ Photo ${data.capture_count}/${data.total_captures} captured`;
                    captureProgress.style.display = 'block';
                } else {
                    captureProgress.style.display = 'none';
                }
            }
            
            // Check if we should trigger photo capture (only once per CAPTURE_DONE state)
            if (data.trigger_capture === true && !lastCaptureTriggered) {
                console.log('üì∏ Capture triggered by state update');
                lastCaptureTriggered = true;  // Mark as triggered
                setTimeout(() => capturePhoto(), 100);
            }
            
            // Show processed frame (except during countdown for performance)
            if (currentState !== 'COUNTDOWN') {
                processedFrame.src = data.frame;
                processedFrame.style.display = 'block';
                video.style.display = 'none';
            } else {
                processedFrame.style.display = 'none';
                video.style.display = 'block';
            }
            
            // Update gesture info
            if (data.gesture) {
                gestureInfo.textContent = `Detected: ${data.gesture}`;
            } else {
                gestureInfo.textContent = 'No gesture detected';
            }
            
            updateStatus(data);
        });

        function updateStatus(data) {
            const { state, timer_value, countdown: countdownValue, streak_progress, capture_count, total_captures } = data;
            
            countdown.style.display = 'none';
            progressContainer.style.display = 'none';
            
            switch(state) {
                case 'PROMPT_TIMER':
                    statusText.textContent = 'Welcome to PhotoBooth Strip!';
                    statusText.innerHTML += '<br><small>Show 1-5 fingers to set your timer</small>';
                    break;
                    
                case 'DETECTING_FINGERS':
                    statusText.textContent = 'Hold steady...';
                    if (streak_progress) {
                        progressContainer.style.display = 'block';
                        const percent = (streak_progress.current / streak_progress.required) * 100;
                        progressFill.style.width = percent + '%';
                    }
                    break;
                    
                case 'TIMER_SET':
                case 'AWAIT_THUMBS_UP':
                    statusText.textContent = `Timer set to ${timer_value} seconds!`;
                    statusText.innerHTML += '<br><small>üëç Thumbs up to START | üëä Fist to CHANGE</small>';
                    if (capture_count > 0) {
                        statusText.innerHTML += `<br><small>Taking ${total_captures} photos total</small>`;
                    }
                    if (streak_progress) {
                        progressContainer.style.display = 'block';
                        const percent = (streak_progress.current / streak_progress.required) * 100;
                        progressFill.style.width = percent + '%';
                    }
                    break;
                    
                case 'COUNTDOWN':
                    countdown.style.display = 'block';
                    if (countdownValue !== null && countdownValue !== undefined) {
                        countdown.textContent = countdownValue > 0 ? countdownValue : 'üì∏ Smile!';
                        console.log(`‚è± Countdown: ${countdownValue}`);
                    }
                    if (capture_count > 0) {
                        statusText.textContent = `Photo ${capture_count + 1}/${total_captures} - Get ready!`;
                    } else {
                        statusText.textContent = 'Get ready for first photo!';
                    }
                    break;
                    
                case 'CAPTURE_DONE':
                    if (capture_count < total_captures) {
                        statusText.textContent = `Photo ${capture_count}/${total_captures} captured! üéâ`;
                        statusText.innerHTML += '<br><small>Get ready for next photo...</small>';
                    } else {
                        statusText.textContent = 'Creating your photo strip...';
                    }
                    break;
            }
        }

        function capturePhoto() {
            console.log('üì∏ Capture photo function called');
            console.log(`üîç Current capture count from last state: ${captureProgress.textContent}`);
            
            try {
                const captureCanvas = document.createElement('canvas');
                captureCanvas.width = video.videoWidth;
                captureCanvas.height = video.videoHeight;
                const captureCtx = captureCanvas.getContext('2d');
                
                captureCtx.drawImage(video, 0, 0, captureCanvas.width, captureCanvas.height);
                const imageData = captureCanvas.toDataURL('image/png');
                
                console.log(`‚úÖ Image captured at ${captureCanvas.width}x${captureCanvas.height}`);
                console.log(`üì¶ Image size: ${(imageData.length / 1024).toFixed(2)} KB`);
                console.log(`‚è∞ Timestamp: ${new Date().toLocaleTimeString()}.${new Date().getMilliseconds()}`);
                
                socket.emit('save_photo', { image: imageData });
                console.log('üì§ Sent photo to server for saving\n');
            } catch (error) {
                console.error('‚ùå Error capturing photo:', error);
            }
        }

        socket.on('strip_ready', (data) => {
            console.log('üéâ Strip ready:', data.filename);
            currentStripFilename = data.filename;
            
            // Show the strip preview
            stripImage.src = `/${data.filename}`;
            stripPreview.classList.add('show');
            
            // Hide video and status
            document.getElementById('videoContainer').style.display = 'none';
            document.querySelector('.status').style.display = 'none';
        });

        socket.on('photo_received', (data) => {
            console.log(`‚úÖ Photo ${data.count}/${data.total} acknowledged by server`);
        });

        socket.on('photo_error', (data) => {
            console.error('‚ùå Photo error:', data.error);
            statusText.innerHTML = `‚ùå Error: ${data.error}<br><small>Please try again</small>`;
        });

        function downloadStrip() {
            if (currentStripFilename) {
                const link = document.createElement('a');
                link.href = `/${currentStripFilename}`;
                link.download = currentStripFilename.split('/').pop();
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                console.log('üì• Downloading strip');
            }
        }

        function startNewStrip() {
            // Hide strip preview
            stripPreview.classList.remove('show');
            
            // Show video and status again
            document.getElementById('videoContainer').style.display = 'block';
            document.querySelector('.status').style.display = 'block';
            
            // Reset capture progress display
            captureProgress.style.display = 'none';
            
            console.log('üîÑ Starting new strip');
        }

        socket.on('connected', (data) => {
            console.log('‚úÖ Connected to server. Session:', data.session);
        });

        socket.on('disconnect', () => {
            console.warn('‚ö†Ô∏è Disconnected from server');
        });

        socket.on('connect_error', (error) => {
            console.error('‚ùå Connection error:', error);
        });

        socket.on('error', (error) => {
            console.error('‚ùå Socket error:', error);
        });
    </script>
</body>
</html>